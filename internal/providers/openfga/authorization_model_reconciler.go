package openfga

import (
	"context"
	"encoding/hex"
	"fmt"
	"hash/fnv"
	"maps"
	"strings"

	iampb "buf.build/gen/go/datum-cloud/iam/protocolbuffers/go/datum/iam/v1alpha"
	openfgav1 "github.com/openfga/api/proto/openfga/v1"
	"go.datum.net/iam/internal/storage"
	"google.golang.org/protobuf/types/known/wrapperspb"
)

type AuthorizationModelReconciler struct {
	StoreID string
	Client  openfgav1.OpenFGAServiceClient

	// Storage interface for interacting with IAM services
	ServiceStorage storage.ResourceServer[*iampb.Service]
}

func (r *AuthorizationModelReconciler) ReconcileAuthorizationModel(ctx context.Context) error {
	currentAuthorizationModel, err := r.getCurrentAuthorizationModel(ctx)
	if err != nil {
		return fmt.Errorf("failed to get current authorization model: %w", err)
	}

	services, err := r.getAllServices(ctx)
	if err != nil {
		return err
	}

	newAuthorizationModel, err := r.createExpectedAuthorizationModel(services)
	if err != nil {
		return fmt.Errorf("failed to create new authorization model: %w", err)
	}

	mergedAuthorizationModel := &openfgav1.AuthorizationModel{
		SchemaVersion: newAuthorizationModel.SchemaVersion,
		// Conditions are not dynamically generated by the IAM system so we can
		// safely set the conditions to whatever is already in the authorization
		// model.
		//
		// TODO: Update when conditions are dynamically created by the IAM system.
		Conditions: currentAuthorizationModel.Conditions,
	}

	// Go through the existing type definitions and add any that were provided
	// through the OpenFGA schema language.
	for _, typeDefinition := range currentAuthorizationModel.TypeDefinitions {
		// The type definitions added by the IAM system will always be in the
		// format `{service_name}/{resource_type}`. Since this format is only
		// valid when building the resource model in JSON, we can safely
		// guarantee that type definitions added by Datum OS through the OpenFGA
		// schema language will never contain a "/" character.
		if len(strings.Split(typeDefinition.Type, "/")) == 1 {
			mergedAuthorizationModel.TypeDefinitions = append(mergedAuthorizationModel.TypeDefinitions, typeDefinition)
		}
	}

	mergedAuthorizationModel.TypeDefinitions = append(mergedAuthorizationModel.TypeDefinitions, newAuthorizationModel.TypeDefinitions...)

	_, err = r.Client.WriteAuthorizationModel(ctx, &openfgav1.WriteAuthorizationModelRequest{
		StoreId:         r.StoreID,
		SchemaVersion:   mergedAuthorizationModel.SchemaVersion,
		TypeDefinitions: mergedAuthorizationModel.TypeDefinitions,
		Conditions:      mergedAuthorizationModel.Conditions,
	})
	if err != nil {
		return fmt.Errorf("failed to reconcile authorization model: %w", err)
	}

	return nil
}

func (r *AuthorizationModelReconciler) getAllServices(ctx context.Context) (map[string]*iampb.Service, error) {
	services := map[string]*iampb.Service{}
	var pageToken string
	for {
		servicesPage, err := r.ServiceStorage.ListResources(ctx, &storage.ListResourcesRequest{
			PageSize:  100,
			PageToken: pageToken,
		})
		if err != nil {
			return nil, err
		}

		for _, service := range servicesPage.Resources {
			services[service.Name] = service
		}

		pageToken = servicesPage.NextPageToken

		if pageToken == "" {
			break
		}
	}

	return services, nil
}

func (r *AuthorizationModelReconciler) getCurrentAuthorizationModel(ctx context.Context) (*openfgav1.AuthorizationModel, error) {
	models, err := r.Client.ReadAuthorizationModels(ctx, &openfgav1.ReadAuthorizationModelsRequest{
		StoreId: r.StoreID,
		// Only request the first result because it'll always be the latest
		// authorization model that was created for the store.
		PageSize: wrapperspb.Int32(1),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list authorization models: %w", err)
	}

	if len(models.AuthorizationModels) == 0 {
		// No authorization model has been created yet so we'll just return an
		// empty model.
		return &openfgav1.AuthorizationModel{}, nil
	}

	// Retrieve the full authorization model definition
	resp, err := r.Client.ReadAuthorizationModel(ctx, &openfgav1.ReadAuthorizationModelRequest{
		StoreId: r.StoreID,
		Id:      models.AuthorizationModels[0].Id,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get authorization model: %w", err)
	}

	return resp.AuthorizationModel, nil
}

func (r *AuthorizationModelReconciler) createExpectedAuthorizationModel(services map[string]*iampb.Service) (*openfgav1.AuthorizationModel, error) {
	permissions, err := getAllPermissions(services)
	if err != nil {
		return nil, err
	}

	resourceGraph, err := getResourceGraph(services)
	if err != nil {
		return nil, fmt.Errorf("failed to get resource graph: %v", err)
	}

	typeDefinitions := []*openfgav1.TypeDefinition{
		getUserTypeDefinition(),
		getRoleTypeDefinition(permissions),
		getRoleBindingTypeDefinition(permissions),
	}

	// TODO: We may be able to optimize which permissions are assigned to each
	//       resource. All permissions are attached to all resources just to make
	//       it easy and not have to add validation for making sure a permission
	//       is available on a resource.
	for _, typeDefinition := range getResourceTypeDefinitions(permissions, resourceGraph) {
		typeDefinitions = append(typeDefinitions, typeDefinition)
	}

	return &openfgav1.AuthorizationModel{
		SchemaVersion:   "1.2",
		TypeDefinitions: typeDefinitions,
	}, nil
}

func getResourceParentRelatedTypes(parents []string) (relations []*openfgav1.RelationReference) {
	for _, parent := range parents {
		relations = append(relations, &openfgav1.RelationReference{
			Type: parent,
		})
	}
	return
}

func getResourceTypeDefinitions(permissions []string, node *resourceGraphNode) map[string]*openfgav1.TypeDefinition {
	types := map[string]*openfgav1.TypeDefinition{}
	types[node.ResourceType] = getResourceTypeDefinition(permissions, node)
	for _, child := range node.ChildResources {
		maps.Copy(types, getResourceTypeDefinitions(permissions, child))
	}
	return types
}

func getResourceTypeDefinition(permissions []string, resourceNode *resourceGraphNode) *openfgav1.TypeDefinition {
	typeDefinition := &openfgav1.TypeDefinition{
		Type: resourceNode.ResourceType,
		Metadata: &openfgav1.Metadata{
			Relations: map[string]*openfgav1.RelationMetadata{
				// All resources can have a role binding associated with it to
				// grant a subject access directly to the Resource. Permissions
				// bound to the resource will be inherited by any child
				// resources.
				"iam.datumapis.com/RoleBinding": {
					DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
						{
							Type: "iam.datumapis.com/RoleBinding",
						},
					},
				},
			},
			SourceInfo: &openfgav1.SourceInfo{
				File: "dynamically_managed_iam_datumapis_com.fga",
			},
			Module: strings.Split(resourceNode.ResourceType, "/")[0],
		},
		Relations: map[string]*openfgav1.Userset{
			"iam.datumapis.com/RoleBinding": {
				Userset: &openfgav1.Userset_This{},
			},
		},
	}

	// Only create a parent reference if the resource has parent relationships and
	// we're not working on the root resource.
	if len(resourceNode.ParentResources) > 0 {
		typeDefinition.Metadata.Relations["parent"] = &openfgav1.RelationMetadata{
			DirectlyRelatedUserTypes: getResourceParentRelatedTypes(resourceNode.ParentResources),
		}
		typeDefinition.Relations["parent"] = &openfgav1.Userset{
			Userset: &openfgav1.Userset_This{},
		}
	}

	for _, permission := range permissions {
		hashedPermission := hashPermission(permission)

		typeDefinition.Relations[hashedPermission] = &openfgav1.Userset{
			Userset: &openfgav1.Userset_Union{
				Union: &openfgav1.Usersets{
					Child: []*openfgav1.Userset{
						{
							Userset: &openfgav1.Userset_TupleToUserset{
								TupleToUserset: &openfgav1.TupleToUserset{
									Tupleset: &openfgav1.ObjectRelation{
										Relation: "iam.datumapis.com/RoleBinding",
									},
									ComputedUserset: &openfgav1.ObjectRelation{
										Relation: hashedPermission,
									},
								},
							},
						},
					},
				},
			},
		}

		if len(resourceNode.ParentResources) > 0 {
			typeDefinition.Relations[hashedPermission].GetUnion().Child = append(typeDefinition.Relations[hashedPermission].GetUnion().Child,
				&openfgav1.Userset{
					Userset: &openfgav1.Userset_TupleToUserset{
						TupleToUserset: &openfgav1.TupleToUserset{
							Tupleset: &openfgav1.ObjectRelation{
								Relation: "parent",
							},
							ComputedUserset: &openfgav1.ObjectRelation{
								Relation: hashedPermission,
							},
						},
					},
				},
			)
		}
	}

	return typeDefinition
}

func getAllPermissions(services map[string]*iampb.Service) ([]string, error) {
	var permissions []string
	for _, service := range services {
		for _, resource := range service.GetSpec().GetResources() {
			for _, permission := range resource.GetPermissions() {
				permissions = append(permissions, fmt.Sprintf("%s/%s.%s", service.ServiceId, resource.Plural, permission))
			}
		}
	}
	return permissions, nil
}

func getUserTypeDefinition() *openfgav1.TypeDefinition {
	return &openfgav1.TypeDefinition{
		Type: "iam.datumapis.com/InternalUser",
		Metadata: &openfgav1.Metadata{
			Relations: map[string]*openfgav1.RelationMetadata{},
			SourceInfo: &openfgav1.SourceInfo{
				File: "dynamically_managed_iam_datumapis_com.fga",
			},
			Module: "iam.datumapis.com",
		},
		Relations: map[string]*openfgav1.Userset{},
	}
}

func getRoleTypeDefinition(permissions []string) *openfgav1.TypeDefinition {
	// Create a new type definition for the base role type that will be used to
	// create custom roles. These roles will always be related to a "user" type
	// through a role binding.
	role := &openfgav1.TypeDefinition{
		// The InternalRole type will represent the application of an Role in the
		// OpenFGA backend. The standard Role type is only used to gate access to a
		// role resource.
		Type: "iam.datumapis.com/InternalRole",
		Metadata: &openfgav1.Metadata{
			Relations: map[string]*openfgav1.RelationMetadata{
				"assignee": {
					DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
						{
							Type: "iam.datumapis.com/InternalUser",
						},
					},
				},
			},
			SourceInfo: &openfgav1.SourceInfo{
				File: "dynamically_managed_iam_datumapis_com.fga",
			},
			Module: "iam.datumapis.com",
		},
		Relations: map[string]*openfgav1.Userset{
			"assignee": {
				Userset: &openfgav1.Userset_This{
					This: &openfgav1.DirectUserset{},
				},
			},
		},
	}

	for _, permission := range permissions {
		hashedPermission := hashPermission(permission)

		role.Metadata.Relations[hashedPermission] = &openfgav1.RelationMetadata{
			DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
				{
					Type:               "iam.datumapis.com/InternalUser",
					RelationOrWildcard: &openfgav1.RelationReference_Wildcard{},
				},
			},
		}
		role.Relations[hashedPermission] = &openfgav1.Userset{
			Userset: &openfgav1.Userset_This{
				This: &openfgav1.DirectUserset{},
			},
		}
	}

	return role
}

func getRoleBindingTypeDefinition(permissions []string) *openfgav1.TypeDefinition {
	// Create a new type definition for the base role type that will be used to
	// create custom roles. These roles will always be related to a "user" type
	// through a role binding.
	roleBinding := &openfgav1.TypeDefinition{
		Type: "iam.datumapis.com/RoleBinding",
		Metadata: &openfgav1.Metadata{
			Relations: map[string]*openfgav1.RelationMetadata{
				"iam.datumapis.com/InternalRole": {
					DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
						{
							Type: "iam.datumapis.com/InternalRole",
						},
					},
				},
				"iam.datumapis.com/InternalUser": {
					DirectlyRelatedUserTypes: []*openfgav1.RelationReference{
						{
							Type: "iam.datumapis.com/InternalUser",
						},
						{
							Type:               "iam.datumapis.com/InternalUser",
							RelationOrWildcard: &openfgav1.RelationReference_Wildcard{},
						},
					},
				},
			},
			SourceInfo: &openfgav1.SourceInfo{
				File: "dynamically_managed_iam_datumapis_com.fga",
			},
			Module: "iam.datumapis.com",
		},
		Relations: map[string]*openfgav1.Userset{
			"iam.datumapis.com/InternalRole": {
				Userset: &openfgav1.Userset_This{
					This: &openfgav1.DirectUserset{},
				},
			},
			"iam.datumapis.com/InternalUser": {
				Userset: &openfgav1.Userset_This{
					This: &openfgav1.DirectUserset{},
				},
			},
		},
	}

	for _, permission := range permissions {
		hashedPermission := hashPermission(permission)

		roleBinding.Relations[hashedPermission] = &openfgav1.Userset{
			Userset: &openfgav1.Userset_Intersection{
				Intersection: &openfgav1.Usersets{
					Child: []*openfgav1.Userset{
						{
							Userset: &openfgav1.Userset_ComputedUserset{
								ComputedUserset: &openfgav1.ObjectRelation{
									Relation: "iam.datumapis.com/InternalUser",
								},
							},
						},
						{
							Userset: &openfgav1.Userset_TupleToUserset{
								TupleToUserset: &openfgav1.TupleToUserset{
									ComputedUserset: &openfgav1.ObjectRelation{
										Relation: hashedPermission,
									},
									Tupleset: &openfgav1.ObjectRelation{
										Relation: "iam.datumapis.com/InternalRole",
									},
								},
							},
						},
					},
				},
			},
		}
	}

	return roleBinding
}

func hashPermission(permission string) string {
	hasher := fnv.New32a()
	hasher.Write([]byte(permission))

	return hex.EncodeToString(hasher.Sum(nil))
}

func HashPermission(permission string) string {
	return hashPermission(permission)
}
